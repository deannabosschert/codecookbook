// note: tried to put this in .eleventy.js for immediate reload, but it didn't work and it's not really necessary unless the json file itself is updated
const fs = require('fs')
const data = require('../styles/design-tokens.json') // fetch data from design-tokens.json, which is generated by figma
const varablePres = ['tiny', 'small', 'middle', 'medium', 'large', 'x-large', 'xx-large', 'xxx-large', 'hughmongus']

toScss('color', 'variables', data)
toScss('font', 'properties', data)
// showAllDataTokens('font', 'all', data)  // TODO for later (see functions at end of file)

function toScss(type, output, data) {
    let dataArray = toObjectArray(type, output, data[type])
    let scss
    if (output == 'variables') { // ugly if-solution for now
        scss = toScssVariables(type, dataArray)
    } else if (output == 'properties') {
        scss = toScssProperties(dataArray)
    } else {
        console.log('error: output not found')
    }
    writeFile(type, scss)
}


// map data to array of objects
function toObjectArray(type, output, data) {
    let array = []
    if (type == 'color') { // ugly if-solution for now
        for (let key in data) {
            array.push({
                [key]: {
                    [type]: data[key].value
                }
            })
        }
        return array
    } else if (type == 'font') {
        for (let key in data) {
            let property = data[key].value
            let values = ''
            for (let key in property) {
                values += `${   sanitizeString(key)   }: ${property[key]}${addUnit(sanitizeString(key))};\n`
            }
            array.push({
                [key]: `{ ${values} }`
            })
        }
        return array
    } else {
        console.log('error: output not found')
    }
}

// map array of objects to list of ready-to-use scss variables
function toScssVariables(type, data) {
    let scss = ''
    console.log(data)
    data.forEach(item => {
        for (let key in item) {
            scss += `$${replaceSpaceWithDash(key)}: ${item[key][type]};\n`
        }
    })
    return scss
}

// map array of objects to list of assigned properties to heading in scss
function toScssProperties(data) {
    let scss = ''
    data.forEach(item => {
        for (let key in item) {
            scss += `.${sanitizeString(key)} ${item[key]} \n`
        }
    })
    return scss
}

function sanitizeString(string) { // ugly solution for now, promise to fix later (pun intended)
    let withoutDash = replaceSpaceWithDash(string)
    let kebabCase = camelCaseToKebabCase(withoutDash)
    return convertOddNames(kebabCase)
}

// scss variable names can't have spaces
function replaceSpaceWithDash(string) {
    return string.replace(/ /g, '-')
}

// convert to actual css properties
function camelCaseToKebabCase(string) {
    return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()
}

// some names are odd (might be editable in figma dev plugin?), so we need to convert them manually
function convertOddNames(string) {
    if (string == 'text-case') {
        return 'text-transform'
    } else if (string == 'paragraph-indent') {
        return 'text-indent'
    } else if (string == 'paragraph-spacing') {
        return 'word-spacing'
    } else {
        return string
    }
}

function addUnit(property) {
    if (property == 'font-size' || property == 'line-height') {
        return 'px'
    } else {
        return ''
    }
}

function removeDuplicates(array) {
    return array.filter((item, pos) => {
        return array.indexOf(item) == pos
    })
}

function writeFile(type, scss) {
    fs.writeFile(`assets/css/settings/_settings.${type}.scss`, scss, (err) => {
        if (err) throw err
        console.log('The scss file has been generated from data and saved!')
    })
}




// TODO FOR LATER
// note: beware of using type or output correctly..
function showAllDataTokens(type, output, data) {
    let dataArray = toObjectArray(output, data[type])
    let scss = generateVariables(dataArray)
    //  writeFile(type, scss)
}

// map data to array of objects
function toObjectArrayData(output, data) {
    if (output == 'typography') {
        let oneProperty = ''
        let onePropertyArray = []
        for (let key in data) {
            let property = data[key]
            for (let key in property) {
                // if (key == 'fontSize') { // example; to be replaced with a loop later
                //     oneProperty = `${sanitizeString(key)}`
                //     onePropertyArray.push(`${property[key].value}${addUnit(sanitizeString(key))}`)
                // }
                oneProperty = `${sanitizeString(key)}`
                onePropertyArray.push(`${property[key].value}${addUnit(sanitizeString(key))}`)
            }
        }
        array.push({
            [oneProperty]: onePropertyArray
        })
        return array
    }
}

function generateVariables(data) {
    // probleem hierbij is dat alles continu overschreven wordt --> leuk om later nog eens naar te kijken maar atm niet relevant voor dit project
    let listWithAll = ''
    let dinges = data.map(item => {
        Object.keys(item).map(key => {
            console.log(key)
            console.log(item[key])
        })
        for (let key in item) {
            listWithAll += `$${key}: ${item[key]};\n`
        }
    })
    data.forEach(variable => {
        let listWithNames = ''
        let theKey = ''
        let bonusKey = ''
        let listOfValues = []
        theKey = Object.keys(variable)[0]
        for (let key in variable) {
            bonusKey = key
            listOfValues.push(variable[key])
        }
        //    listOfValues.flat().sort().forEach(value => {
        //         listWithNames+= `$font-size-large: ${value}; \n`
        //         return value
        //     })
        let cleanList = listOfValues.flat().sort()
        let uniqueList = removeDuplicates(cleanList) // remove duplicates from cleanList
        // for loop with index
        for (let i = 0; i < uniqueList.length; i++) {
            listWithNames += `$${bonusKey}-${varablePres[i]}: ${uniqueList[i]}; \n`
        }
        listWithAll += listWithNames
    })
    return listWithAll
}
