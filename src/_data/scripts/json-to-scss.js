// note: tried to put this in .eleventy.js for immediate reload, but it didn't work and it's not really necessary unless the json file itself is updated
const fs = require('fs')
const data = require('../styles/design-tokens.json') // fetch data from design-tokens.json, which is generated by figma
const varablePres = ['tiny', 'small', 'middle', 'medium', 'large', 'x-large', 'xx-large', 'xxx-large', 'hughmongus']
const htmlElementsArray = ["a",
    "abbr",
    "acronym",
    "address",
    "applet",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "basefont",
    "bdi",
    "bdo",
    "bgsound",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "content",
    "data",
    "datalist",
    "dd",
    "decorator",
    "del",
    "details",
    "dfn",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "isindex",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "listing",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "nobr",
    "noframes",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "plaintext",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "shadow",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "xmp"
]

toScss('color', 'variables', data)
toScss('font', 'properties', data)
// showAllDataTokens('font', 'all', data)  // TODO for later (see functions at end of file)

function toScss(type, output, data) {
    let dataArray = toObjectArray(type, output, data[type])
    let scss
    if (output == 'variables') { // ugly if-solution for now
        scss = toScssVariables(type, dataArray)
    } else if (output == 'properties') {
        scss = toScssProperties(dataArray)
    } else {
        console.log('error: output not found')
    }
    writeFile(type, scss)
}

// map data to array of objects
function toObjectArray(type, output, data) {
    let array = []
    if (type == 'color') { // ugly if-solution for now
        for (let key in data) {
            array.push({
                [key]: {
                    [type]: data[key].value
                }
            })
        }
        return array
    } else if (type == 'font') {
        for (let key in data) {
            let property = data[key].value
            let values = ''
            for (let key in property) {
                values += `${   sanitizeString(key)   }: ${property[key]}${addUnit(sanitizeString(key))};\n`
            }

            array.push({
                [key]: `{ ${values} }`
            })
        }

        return array
    } else {
        console.log('error: output not found')
    }
}

// map array of objects to list of ready-to-use scss variables
function toScssVariables(type, data) {
    let scss = ''
    data.forEach(item => {
        for (let key in item) {
            let selector = sanitizeString(key)
            let properties = item[key]

            scss += `$${selector}: ${properties[type]};\n`
        }
    })
    return scss
}

// map array of objects to list of assigned properties to heading in scss
function toScssProperties(data) {
    let scss = ''
    data.forEach(item => {
        for (let key in item) {
            let selector = sanitizeString(key)
            let properties = item[key]

            if (htmlElementsArray.includes(selector) == true) { // if it's an html element
                scss += `${selector} ${properties} \n`
            } else {
                scss += `.${selector} ${properties} \n` // add class-prefix
            }
        }
    })
    return scss
}

function sanitizeString(string) { // ugly solution for now, promise to fix later (pun intended)
    let withoutDash = replaceSpaceWithDash(string)
    let kebabCase = camelCaseToKebabCase(withoutDash)
    let convertedNames = convertOddNames(kebabCase)
    let namedElement = nameToElement(convertedNames)
    return namedElement
}

// scss variable names can't have spaces
function replaceSpaceWithDash(string) {
    return string.replace(/ /g, '-')
}

// convert to actual css properties
function camelCaseToKebabCase(string) {
    return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()
}

// some names are odd (might be editable in figma dev plugin?), so we need to convert them manually
function convertOddNames(string) {
    if (string == 'text-case') {
        return 'text-transform'
    } else if (string == 'paragraph-indent') {
        return 'text-indent'
    } else if (string == 'paragraph-spacing') {
        return 'word-spacing'
    } else {
        return string
    }
}

function nameToElement(string) {
    if (string.startsWith('heading') == true) {
        return `h${string.charAt(8)}`
    } else {
        return string
    }
}

function addUnit(property) {
    if (property == 'font-size' || property == 'line-height') {
        return 'px'
    } else {
        return ''
    }
}

function removeDuplicates(array) {
    return array.filter((item, pos) => {
        return array.indexOf(item) == pos
    })
}

function writeFile(type, scss) {
    fs.writeFile(`assets/css/settings/_settings.${type}.scss`, scss, (err) => {
        if (err) throw err
        console.log('The scss file has been generated from data and saved!')
    })
}

// TODO FOR LATER
// note: beware of using type or output correctly..
function showAllDataTokens(type, output, data) {
    let dataArray = toObjectArray(output, data[type])
    let scss = generateVariables(dataArray)
    //  writeFile(type, scss)
}

// map data to array of objects
function toObjectArrayData(output, data) {
    if (output == 'typography') {
        let oneProperty = ''
        let onePropertyArray = []
        for (let key in data) {
            let property = data[key]
            for (let key in property) {
                // if (key == 'fontSize') { // example; to be replaced with a loop later
                //     oneProperty = `${sanitizeString(key)}`
                //     onePropertyArray.push(`${property[key].value}${addUnit(sanitizeString(key))}`)
                // }
                oneProperty = `${sanitizeString(key)}`
                onePropertyArray.push(`${property[key].value}${addUnit(sanitizeString(key))}`)
            }
        }
        array.push({
            [oneProperty]: onePropertyArray
        })
        return array
    }
}

function generateVariables(data) {
    // probleem hierbij is dat alles continu overschreven wordt --> leuk om later nog eens naar te kijken maar atm niet relevant voor dit project
    let listWithAll = ''
    let dinges = data.map(item => {
        Object.keys(item).map(key => {
            console.log(key)
            console.log(item[key])
        })
        for (let key in item) {
            listWithAll += `$${key}: ${item[key]};\n`
        }
    })
    data.forEach(variable => {
        let listWithNames = ''
        let theKey = ''
        let bonusKey = ''
        let listOfValues = []
        theKey = Object.keys(variable)[0]
        for (let key in variable) {
            bonusKey = key
            listOfValues.push(variable[key])
        }
        //    listOfValues.flat().sort().forEach(value => {
        //         listWithNames+= `$font-size-large: ${value}; \n`
        //         return value
        //     })
        let cleanList = listOfValues.flat().sort()
        let uniqueList = removeDuplicates(cleanList) // remove duplicates from cleanList
        // for loop with index
        for (let i = 0; i < uniqueList.length; i++) {
            listWithNames += `$${bonusKey}-${varablePres[i]}: ${uniqueList[i]}; \n`
        }
        listWithAll += listWithNames
    })
    return listWithAll
}